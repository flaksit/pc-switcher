# Implementation Review 5 — 2025-11-17

## Summary
The foundation branch ships a solid skeleton: module contracts exist, the orchestrator enforces validate→pre→sync→post ordering, version self-installation is wired through `VersionManager`, dummy modules exercise success/failure paths, CLI locking/logging/tests all pass (`uv run pytest`). Snapshot infrastructure, configuration defaults, and installation tooling are also present. However, several P1 requirements remain unmet, primarily around disk safety, interrupt cleanup, and snapshot generality. These need to be addressed before the spec can be signed off.

## What Works
- **Module interface & orchestration (FR-001…FR-004, FR-019, FR-046–FR-048):** `SyncModule` defines the required lifecycle, the orchestrator loads modules strictly in config order, captures validation errors, and stops immediately on the first `SyncError`, logging CRITICAL and calling `abort(timeout=5.0)`.
- **Self-installation (FR-005–FR-007):** `_ensure_version_sync()` runs before any other action. It installs/upgrades via `uv tool install git+https://github.com/flaksit/pc-switcher@v<version>` and aborts if the target is newer or installation fails.
- **Snapshot safety basics (FR-008–FR-013, FR-015):** `BtrfsSnapshotsModule` validates source/target subvolumes, creates pre/post snapshots with the mandated naming scheme, and surfaces rollback through `_offer_rollback()` plus a dedicated `rollback` CLI command. Cleanup defaults (`keep_recent`, `max_age_days`) live in config and are used as CLI defaults.
- **Logging & progress (FR-018–FR-023, FR-043–FR-045):** `configure_logging()` writes Structlog JSON to `~/.local/share/pc-switcher/logs/sync-<timestamp>.log` with independent CLI/file levels. Progress events are logged at FULL and forwarded to the Rich UI.
- **Testing & tooling (FR-038–FR-042, FR-035–FR-037):** Dummy modules implement the required behaviors, and the `scripts/setup.sh` installer checks for btrfs, installs deps, and seeds the default config. `uv run pytest` currently passes all 52 tests.

## Gaps & Required Fixes
1. **Runtime disk monitoring ignores the target and never aborts (FR-017).** `_start_disk_monitoring()` only watches the local `/` path and merely prints a warning when thresholds are exceeded. The spec requires monitoring *both* source and target at the configured interval and logging CRITICAL + aborting the sync when free space drops below `disk.runtime_minimum`. You’ll need a polling loop (or reuse `DiskMonitor`) for the remote host via `RemoteExecutor`, and wire the callback to raise `SyncError`/set `abort_requested` when thresholds are violated.
2. **Interrupt handling doesn’t clean up target processes or connections (User Story 5, FR-025 & FR-027).** When SIGINT is received, the handler raises `KeyboardInterrupt` and `cleanup_current_module()` calls `module.abort()`, but no code calls `TargetConnection.terminate_processes()` or `TargetConnection.disconnect()`. As a result, remote helper scripts can keep running, violating the “no orphaned processes” requirement and the mandate to send termination signals to the target side. Add explicit cleanup in the interrupt path (and when sessions end) to kill remote `pc-switcher`/child processes and close the SSH connection before exiting.
3. **Snapshot manager only supports three hard-coded subvolumes (FR-008, FR-015, Config Schema).** `_find_subvolume_path()` raises `SyncError` unless the name is exactly `@`, `@home`, or `@root`, even though the config schema and acceptance scenarios require arbitrary entries from `btrfs subvolume list /`. Any user who follows the spec and adds, say, `@var` or a custom home subvolume will fail during pre-sync snapshots despite validation passing. Replace the hard-coded map with a lookup that inspects mounted subvolumes (both locally and on the target) so every configured name can be resolved.
4. **Snapshot cleanup only affects the source machine (FR-014 / User Story 3 Scenario 7).** `cleanup_snapshots` scans and deletes `/.snapshots` locally but never touches the corresponding snapshots on the target, even though every sync creates pairs on both sides and the retention policy is defined globally. Extend the command (or create a mirror operation via `RemoteExecutor`) so both source and target snapshots participate in the retention guarantees.
5. **Snapshot progress callbacks break the UI when enabled.** `SnapshotCallbacks.emit_progress()` calls `self._ui.update_progress(percentage, current_item)`, which doesn’t match `TerminalUI.update_progress(module_name: str, percentage: float, item: str = "")`. If the UI is active, this invocation raises a `TypeError` and prevents snapshot creation from reporting progress. Either provide a dedicated UI hook for infrastructure tasks or call `update_progress` with the required module identifier.
6. **Target disk validation only runs once at startup (FR-016).** `_check_disk_space()` measures the remote `/` free space before sync begins, but during long runs disk consumption on the target is never re-validated. Combined with gap #1, the orchestrator can proceed even as the target fills up, contrary to the “abort before state changes” guarantee. Re-run the remote check periodically (or before each module) and stop the sync with a CRITICAL log if the threshold is breached mid-run.

## Recommendations & Next Steps
- Address the six gaps above; they block compliance with the P1 safety/interrupt requirements.
- After implementing the fixes, add targeted tests (e.g., unit tests for remote disk monitoring thresholds, interrupt cleanup invoking `TargetConnection.terminate_processes`, and snapshot path resolution with custom subvolume names) to prevent regressions.
- Re-run `uv run pytest` and document the new behavior once the changes land.
